package com.ameyakarve.chromepush;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.spec.ECPoint;
import java.security.spec.ECPublicKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import java.util.Base64;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyAgreement;
import javax.crypto.Mac;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.ECPointUtil;
import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;
import org.bouncycastle.jce.spec.ECNamedCurveSpec;
import org.bouncycastle.jce.spec.ECParameterSpec;
import org.json.JSONObject;


/*
 * This Java source file was auto generated by running 'gradle buildInit --type java-library'
 * by 'akarve' at '1/21/16 9:31 PM' with Gradle 2.1
 *
 * @author akarve, @date 1/21/16 9:31 PM
 */

public class ChromePushUtils {
  private final static char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
  private static final byte[] CONTENT_ENCODING = "Content-Encoding: ".getBytes(StandardCharsets.UTF_8);
  private static final byte[] AESGCM128 = "aesgcm".getBytes(StandardCharsets.UTF_8);
  private static final byte[] NONCE = "nonce".getBytes(StandardCharsets.UTF_8);
  private static final byte[] P256 = "P-256".getBytes(StandardCharsets.UTF_8);
  private static final int GCM_TAG_LENGTH = 16; // in bytes
  private static final String SECP256R1 = "secp256r1";
  private static final String HMAC_SHA256 = "HmacSHA256";
  private static final String SHA1_PRNG = "SHA1PRNG";

  public ChromePushUtils() {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
  }

  /**
   * Converts a bytearray to a hexadecimal string
   * @param bytes bytearray
   * @return hexadecimal string
   */
  public static String bytesToHex(final byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j < bytes.length; j++) {
      int v = bytes[j] & 0xFF;
      hexChars[j * 2] = HEX_ARRAY[v >>> 4];
      hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
    }
    return new String(hexChars);
  }

  /**
   * Converts a hexadecimal string to a bytearray
   * @param s hexadecimal string
   * @return bytearray
   */
  public static byte[] hexToBytes(final String s) {
    int len = s.length();
    byte[] data = new byte[len / 2];
    for (int i = 0; i < len; i += 2) {
      data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
    }
    return data;
  }

  /**
   * Creates an ECPublicKey object from a String public key using ECDH using the p256 curve
   * @param publicKey String representation of public key
   * @return Java ECPublicKey representation of key
   * @throws NoSuchAlgorithmException
   * @throws InvalidKeySpecException
   * @throws NoSuchProviderException
   */
  public ECPublicKey createPublicKey(final String publicKey)
      throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {
    ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(SECP256R1); // P256 curve
    KeyFactory kf = KeyFactory.getInstance("ECDH", "BC");
    ECNamedCurveSpec params = new ECNamedCurveSpec(SECP256R1, spec.getCurve(), spec.getG(), spec.getN());
    ECPoint point = ECPointUtil.decodePoint(params.getCurve(), Base64.getUrlDecoder().decode(publicKey));
    ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(point, params);
    return (ECPublicKey) kf.generatePublic(pubKeySpec);
  }

  /**
   * Generates a keypair for ECDH using the p256 curve.
   * Creating a new keypair per request is expensive, but preferred
   * @return ECDH Keypair
   * @throws NoSuchAlgorithmException
   * @throws InvalidAlgorithmParameterException
   * @throws NoSuchProviderException
   */
  public KeyPair generateServerKeyPair()
      throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException {
    ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(SECP256R1); // P256 curve
    KeyPairGenerator g = KeyPairGenerator.getInstance("ECDH", "BC");
    g.initialize(ecSpec, new SecureRandom());
    return g.generateKeyPair();
  }

  /**
   * Converts the ECDH public key to bytes (has to be 65 bytes in length)
   * @param publicKey Public key for ECDH p256 curve
   * @return bytearray representation of key
   */
  public byte[] publicKeyToBytes(final ECPublicKey publicKey) {
    ECPoint point = publicKey.getW();
    String x = point.getAffineX().toString(16);
    String y = point.getAffineY().toString(16);
    
    /*
     *  Format is 04 followed by 32 bytes (64 hex) each for the X,Y coordinates
    */
    StringBuilder sb = new StringBuilder();
    sb.append("04");

    for (int i = 0; i < 64 - x.length(); i++) {
      sb.append(0);
    }
    sb.append(x);

    for (int i = 0; i < 64 - y.length(); i++) {
      sb.append(0);
    }
    sb.append(y);
    return hexToBytes(sb.toString());
  }

  /**
   * Converts the ECDH private key to bytes (has to be 32 bytes in length)
   * @param privateKey Private key for ECDH p256 curve
   * @return bytearray representation of private key
   */
  public byte[] privateKeyToBytes(final ECPrivateKey privateKey) {
    /*
     *  Format is 32 bytes (64 hex) of S 
    */
    StringBuilder sb = new StringBuilder();
    String s = privateKey.getS().toString(16);
    for (int i = 0; i < 64 - s.length(); i++) {
      sb.append(0);
    }
    sb.append(s);
    return hexToBytes(sb.toString());
  }

  /**
   * Computes the shared secret for ECDH using the server keys and the client public key
   * @param serverKeys Server keypair
   * @param clientPublicKey Client public key
   * @return p256dh shared secret
   * @throws NoSuchAlgorithmException
   * @throws InvalidKeyException
   * @throws NoSuchProviderException
   */
  public byte[] generateSharedSecret(final KeyPair serverKeys, final PublicKey clientPublicKey)
      throws NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException {
    KeyAgreement keyAgreement = KeyAgreement.getInstance("ECDH", "BC");
    keyAgreement.init(serverKeys.getPrivate());
    keyAgreement.doPhase(clientPublicKey, true);
    return keyAgreement.generateSecret();
  }

  /**
   * Returns an info record. See sections 3.2 and 3.3 of
   * {https://tools.ietf.org/html/draft-ietf-httpbis-encryption-encoding-00}
   * @param client_public client public key
   * @param server_public server public key
   * @param type info type
   * @return
   * @throws IOException
   */
  public byte[] generateInfo(final byte[] client_public, final byte[] server_public, final byte[] type)
      throws IOException {


    // The start index for each element within the buffer is:
    // value               | length | start  |
    // ---------------------------------------
    // 'Content-Encoding: '|   18   | 0      |
    // type                |   l    | 18     |
    // null byte           |   1    | 18 + l |
    // 'P-256'             |   5    | 19 + l |
    // info                |   135  | 24 + l |
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    outputStream.write(CONTENT_ENCODING); // Append the string “Content-Encoding: “
    outputStream.write(type); // Append the |type|
    outputStream.write((byte) 0); // Append a NULL-byte
    outputStream.write(P256); // Append the string “P-256”

    // The context format is:
    // 0x00 || length(clientPublicKey) || clientPublicKey ||
    //         length(serverPublicKey) || serverPublicKey
    // The lengths are 16-bit, Big Endian, unsigned integers so take 2 bytes each.

    // The keys should always be 65 bytes each. The format of the keys is
    // described in section 4.3.6 of the (sadly not freely linkable) ANSI X9.62
    // specification.
    outputStream.write((byte) 0); // Append a NULL-byte

    outputStream.write((byte) 0); // Append the length of the recipient’s public key (here |client_public|)
    outputStream.write((byte) 65); // as a two-byte integer in network byte order.

    outputStream.write(client_public); // Append the raw bytes (65) of the recipient’s public key.

    outputStream.write((byte) 0); // Append the length of the sender’s public key (here |server_public|)
    outputStream.write((byte) 65); // as a two-byte integer in network byte order.

    outputStream.write(server_public); // Append the raw bytes (65) of the sender’s public key.

    return outputStream.toByteArray();
  }

  public static String createEncryptionHeader(final byte[] salt) {
    // Encode |salt| using the URL-safe base64 encoding, store it in |encoded_salt|.
    // Return the result of concatenating (“salt=”, |encoded_salt|).
    return "salt=" + Base64.getUrlEncoder().encodeToString(salt);
  }

  public static String createCryptoKeyHeader(final byte[] server_public) {
    //Encode |server_public| using the URL-safe base64 encoding, store it in |encoded_server_public|.
    // Return the result of concatenating (“dh=”, |encoded_server_public|).
    return "dh=" + Base64.getUrlEncoder().encodeToString(server_public);
  }

  public byte[] computeSHA256HMAC(final byte[] secret, final byte[] message)
      throws NoSuchAlgorithmException, InvalidKeyException {
    Mac sha256_HMAC = Mac.getInstance(HMAC_SHA256);
    SecretKeySpec secret_key = new SecretKeySpec(secret, HMAC_SHA256);
    sha256_HMAC.init(secret_key);
    return sha256_HMAC.doFinal(message);
  }

  /**
   * Performs an hkdf extract on the message and trims to (lengthToExtract)
   *  * HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
   *
   * This is used to derive a secure encryption key from a mostly-secure shared
   * secret.
   *
   * This is a partial implementation of HKDF tailored to our specific purposes.
   * In particular, for us the value of N will always be 1, and thus T always
   * equals HMAC-Hash(PRK, info | 0x01).
   *
   * See {https://www.rfc-editor.org/rfc/rfc5869.txt}
   * @param secret_key key to perform the HMAC with
   * @param salt random salt bytes
   * @param messageToExtract message to perform hkdf extract on
   * @param lengthToExtract how much to trim the output by
   * @return hkdf extract
   * @throws NoSuchAlgorithmException
   * @throws InvalidKeyException
   */
  public byte[] hkdfExtract(final byte[] secret_key, final byte[] salt, final byte[] messageToExtract,
      final int lengthToExtract)
      throws NoSuchAlgorithmException, InvalidKeyException {
    Mac outerMac = Mac.getInstance(HMAC_SHA256);
    outerMac.init(new SecretKeySpec(salt, HMAC_SHA256));
    byte[] outerResult = outerMac.doFinal(secret_key);
    Mac innerMac = Mac.getInstance(HMAC_SHA256);
    innerMac.init(new SecretKeySpec(outerResult, HMAC_SHA256));
    byte[] message = new byte[messageToExtract.length + 1];
    System.arraycopy(messageToExtract, 0, message, 0, messageToExtract.length);
    message[messageToExtract.length] = (byte) 1;
    byte[] innerResult = innerMac.doFinal(message);
    return Arrays.copyOf(innerResult, lengthToExtract);
  }

  /**
   * Encrypts a message such that it can be sent using the Web Push protocol.
   * You can find out more about the various pieces:
   *  - {https://tools.ietf.org/html/draft-ietf-httpbis-encryption-encoding}
   *  - {https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman}
   *  - {https://tools.ietf.org/html/draft-ietf-webpush-encryption}
   * @param message Message to encrypt
   * @param shared_secret Shared secret computed using the server keys and the client public key
   * @param salt 16 random bytes
   * @param content_encryption_key_info
   * @param nonce_info
   * @param client_auth Client's auth (generated on the browser)
   * @return
   * @throws InvalidKeyException
   * @throws NoSuchAlgorithmException
   * @throws IllegalBlockSizeException
   * @throws InvalidAlgorithmParameterException
   * @throws BadPaddingException
   * @throws NoSuchProviderException
   * @throws NoSuchPaddingException
   */
  public String encryptPayload(final String message, final byte[] shared_secret, final byte[] salt,
      final byte[] content_encryption_key_info, final byte[] nonce_info, final byte[] client_auth)
      throws InvalidKeyException, NoSuchAlgorithmException, IllegalBlockSizeException,
             InvalidAlgorithmParameterException, BadPaddingException, NoSuchProviderException, NoSuchPaddingException {


    // Derive a Pseudo-Random Key (prk) that can be used to further derive our
    // other encryption parameters. These derivations are described in
    // https://tools.ietf.org/html/draft-ietf-httpbis-encryption-encoding-00
    final byte[] prk =
        hkdfExtract(shared_secret, client_auth, "Content-Encoding: auth\0".getBytes(StandardCharsets.UTF_8), 32);

    // Derive the Content Encryption Key
    final byte[] content_encryption_key = hkdfExtract(prk, salt, content_encryption_key_info, 16);

    // Derive the Nonce / iv
    final byte[] nonce = hkdfExtract(prk, salt, nonce_info, 12);

    // Not adding any padding for now. First two bytes are reserved for number of padding bytes (0)
    final byte[] record = ("\0\0" + message).getBytes(StandardCharsets.UTF_8);

    // Set |ciphertext| to the result of encrypting |record| with AEAD_AES_128_GCM, using the |content_encryption_key| as the key, the |nonce| as the nonce/IV, and an authentication tag of 16 bytes. (See function below)
    final byte[] ciphertext = encryptWithAESGCM128(nonce, content_encryption_key, record);

    // Encode the |ciphertext| using the URL-safe base64 encoding, store it in |encoded_ciphertext|.
    return Base64.getUrlEncoder().encodeToString(
        ciphertext);
  }

  /**
   * Encrypt the plaintext message using AES128/GCM
   * @param nonce The iv
   * @param content_encryption_key The private key to use
   * @param record The message to be encrypted
   * @return the encrypted payload
   * @throws NoSuchPaddingException
   * @throws NoSuchAlgorithmException
   * @throws NoSuchProviderException
   * @throws InvalidAlgorithmParameterException
   * @throws InvalidKeyException
   * @throws BadPaddingException
   * @throws IllegalBlockSizeException
   */
  public static byte[] encryptWithAESGCM128(final byte[] nonce, final byte[] content_encryption_key,
      final byte[] record)
      throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException,
             InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
    Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding", "SunJCE");
    SecretKey key = new SecretKeySpec(content_encryption_key, "AES");
    GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, nonce);
    cipher.init(Cipher.ENCRYPT_MODE, key, spec);
    return cipher.doFinal(record);
  }

  /**
   * Generates 16 cryptographically secure random bytes
   * @return 16 byte salt
   * @throws NoSuchAlgorithmException
   */
  public byte[] generateSalt()
      throws NoSuchAlgorithmException {
    byte[] salt = new byte[16];
    SecureRandom.getInstance(SHA1_PRNG).nextBytes(salt);
    return salt;
  }
}
